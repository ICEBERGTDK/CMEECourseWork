Starting code feedback for Dengkui, Week3

Current Points = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 1.69 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: week2, week3, .git, week1, Feedback

Found the following files in parent directory: README.txt, .gitignore

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:

**********************************************************************
*~ 
*.tmp
.vscode*
week1/Code/.log

**********************************************************************

Found README in parent directory, named: README.txt

Printing contents of README.txt:

**********************************************************************
My CMEE Coursework Repository



**********************************************************************

======================================================================
Looking for the weekly directories...

Found 3 weekly directories: week1, week2, week3

The Week3 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK3...

Found the following directories: data, code, sandbox, results

Found the following files: .gitignore, Readme.md

Checking for readme file in weekly directory...

Found README in parent directory, named: Readme.md

Printing contents of Readme.md:

**********************************************************************
## Usage: ##
### R ###
### source() / ctrl&enter ###
### R Data Structure ###
### Useful R function ### 
### Importing and Exporting Data ###
### Control flow tools ###
### Vectorization ###
### Errors and Debugging ###
### Install packages ###
## Data Management and Visualization ##
### Data Wrangling ###
### Data Visualization ###
#### Data exploration with basic plotting ####
#### Histograms ####
#### Subplots ####
#### Overlaying plots ####
#### Boxplots ####
#### Combining plot types ####
#### Saving graphics ####
### ggplot2 ###
#### qplot ####
#### ggplot ####
#### geom argument ####
#### Plotting a matrix####
#### Plotting two dataframes together ####
#### Annotating plots####
### Mathematical display ###
### ggthemes ###


**********************************************************************

Results directory is empty - good! 

Found 26 code files: TreeHeight.R, browse.R, preallocate.R, plotLin.R, PP_Dists.R, try.R, Vectorize2.R, TAutoCorr.R, boilerplate.R, apply1.R, PP_Regress.R, MyBars.R, DataWrang.R, control_flow.R, Vectorize1.R, SQLinR.R, sample.R, apply2.R, Ricker.R, break.R, next.R, R_conditionals.R, GPDD_Data.R, basic_io.R, AutocorrelationInWeather.tex, DataWrangTidy.R

Found the following extra files: AutocorrelationInWeather.pdf
0.5 pt deducted per extra file

Current Points = 99.5

======================================================================
Testing script/code files...

======================================================================
Inspecting script file TreeHeight.R...

File contents are:

**********************************************************************
# This function calculates heights of trees given distance of each tree 
# from its base and angle to its top, using  the trigonometric formula 
#
# height = distance * tan(radians)
#
# ARGUMENTS
# degrees:   The angle of elevation of tree
# distance:  The distance from base of tree (e.g., meters)
#
# OUTPUT
# The heights of the tree, same units as "distance"

TreeHeight <- function(degrees, distance){
  radians <- degrees * pi / 180
  height <- distance * tan(radians)
  print(paste("Tree height is:", height))
  
  return (height)
}
df1 = read.csv("../data/trees.csv",header=T)
df1$Tree.Height.m=TreeHeight(df1$Angle.degrees, df1$Distance.m)

df2 = write.csv(df1,"../results/TreeHts.csv")

**********************************************************************

Testing TreeHeight.R...

Output (only first 500 characters): 


**********************************************************************
  [1] "Tree height is: 27.8021161438536" "Tree height is: 45.2460250644405"
  [3] "Tree height is: 14.6654828109493" "Tree height is: 14.9341751666304"
  [5] "Tree height is: 35.9703591412599" "Tree height is: 32.4102133664874"
  [7] "Tree height is: 17.4582436344144" "Tree height is: 30.1373803987097"
  [9] "Tree height is: 20.3124778877177" "Tree height is: 24.4316633466933"
 [11] "Tree height is: 27.5021323376702" "Tree height is: 25.1559006982628"
 [13] "Tree height is: 29.3924796426504" "Tre
**********************************************************************

Code ran without errors or warnings

Time consumed = 0.20314s

======================================================================
Inspecting script file browse.R...

File contents are:

**********************************************************************
Exponential <- function(N0 = 1,r = 1, generations = 10){
    # Runs a simulation of exponential growth
    # Returns a vector of length generations

    N <- rep(NA,generations)

    N[1] <- N0
    for (t in 2:generations){
        N[t] <- N[t-1] * exp(r)
        browser()
    }
    return (N)
}

plot(Exponential(), type="l", main="Exponential growth")
**********************************************************************

Testing browse.R...

Output (only first 500 characters): 


**********************************************************************
Called from: Exponential()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()
debug: N[t] <- N[t - 1] * exp(r)
debug: browser()

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.27353s

======================================================================
Inspecting script file preallocate.R...

File contents are:

**********************************************************************

NoPreallocFun<-function(x) {
    a <- vector() # empty vector
    for (i in 1:x) {
        a <- c(a, i)
        print(a)
        print(object.size(a))
    }
}
print(system.time(NoPreallocFun(10)))

PreallocFun<-function(x){
    a <- rep(NA, x)
    for (i in 1:x) {
        a[i] <- i
        print(a)
        print(object.size(a))
    }
}
print(system.time(PreallocFun(10)))

**********************************************************************

Testing preallocate.R...

Output (only first 500 characters): 


**********************************************************************
[1] 1
56 bytes
[1] 1 2
56 bytes
[1] 1 2 3
64 bytes
[1] 1 2 3 4
64 bytes
[1] 1 2 3 4 5
80 bytes
[1] 1 2 3 4 5 6
80 bytes
[1] 1 2 3 4 5 6 7
80 bytes
[1] 1 2 3 4 5 6 7 8
80 bytes
[1] 1 2 3 4 5 6 7 8 9
96 bytes
 [1]  1  2  3  4  5  6  7  8  9 10
96 bytes
   user  system elapsed 
  0.022   0.004   0.027 
 [1]  1 NA NA NA NA NA NA NA NA NA
96 bytes
 [1]  1  2 NA NA NA NA NA NA NA NA
96 bytes
 [1]  1  2  3 NA NA NA NA NA NA NA
96 bytes
 [1]  1  2  3  4 NA NA NA NA NA NA
96 bytes
 [1]  1  2  3  4  5 NA N
**********************************************************************

Code ran without errors or warnings

Time consumed = 0.27579s

======================================================================
Inspecting script file plotLin.R...

File contents are:

**********************************************************************
pdf("../results/MyLinReg.pdf")

x <- seq(0, 100, by = 0.5)
y <- -4. + 0.25 * x + rnorm(length(x), mean = 10., sd = 2)
my_data <- data.frame(x = x, y = y)
my_lm <- summary(lm(y ~ x, data = my_data))

p <-  ggplot(my_data, aes(x = x, y = y, colour = abs(my_lm$residual))) +
  geom_point() +
  scale_colour_gradient(low = "black", high = "red") +
  theme(legend.position = "none") +
  scale_x_continuous(expression(alpha^2 * pi / beta * sqrt(Theta)))

p <- p + geom_abline(intercept = my_lm$coefficients[1][1], slope = my_lm$coefficients[2][1], colour = "blue")
p <- p + geom_text(aes(x = 60, y = 0, label = "sqrt(alpha) * 2* pi"), parse = TRUE, size = 6, colour = "green")
p
plot(p)

library(ggthemes)

p <- ggplot(MyDF, aes(x = log(Predator.mass), y = log(Prey.mass), colour = Type.of.feeding.interaction )) + 
  geom_point(size=I(2), shape=I(10)) + theme_bw()
p <- p + geom_rangeframe() + theme_tufte()
p
plot(p)

dev.off()

**********************************************************************

Testing plotLin.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error or warning:
Error in ggplot(my_data, aes(x = x, y = y, colour = abs(my_lm$residual))) : 
  could not find function "ggplot"
Execution halted

======================================================================
Inspecting script file PP_Dists.R...

File contents are:

**********************************************************************
rm(list = ls())
MyDF <- read.csv("../data/EcolArchives-E089-51-D1.csv")
dim(MyDF)
head(MyDF)
require(tidyverse)
dplyr::glimpse(MyDF)
MyDF$Type.of.feeding.interaction <- as.factor(MyDF$Type.of.feeding.interaction)
MyDF$Location <- as.factor(MyDF$Location)

TOFI=unique(MyDF$Type.of.feeding.interaction)

pdf("../results/Pred_Subplots.pdf",11.7,8.3)
par(mfrow=c(1,5))
for (n in 1:length(TOFI)) {
  par(mfg=c(1,n))
  boxplot(log(MyDF$Predator.mass[MyDF$Type.of.feeding.interaction==TOFI[n]]), xlab = TOFI[n],ylab = "log(mass)")
}
mtext("Predator Mass", side = 3, outer = T, line = -3)
graphics.off()

pdf("../results/Prey_Subplots.pdf",11.7,8.3)
par(mfrow=c(1,5))
for (n in 1:length(TOFI)) {
  par(mfg=c(1,n))
  boxplot(log(MyDF$Prey.mass[MyDF$Type.of.feeding.interaction==TOFI[n]]), xlab = TOFI[n],ylab = "log(mass)")
}
mtext("Prey Mass", side = 3, outer = T, line = -3)
graphics.off()

ratio_data = MyDF$Prey.mass/MyDF$Predator.mass
MyDF$ratio = ratio_data
pdf("../results/SizeRatio_Subplots.pdf",11.7,8.3)
par(mfrow=c(1,5))
for (n in 1:length(TOFI)) {
  par(mfg=c(1,n))
  boxplot(log(MyDF$ratio[MyDF$Type.of.feeding.interaction==TOFI[n]]), xlab = TOFI[n],ylab = "ratio")
}
mtext("Ratio", side = 3, outer = T, line = -3)
graphics.off()


df1 <- data.frame()
df2 <- data.frame()
df_final <- data.frame()
mean_pred <- c()
mean_prey <- c()
mean_ratio <- c()
median_pred <- c()
median_prey <- c()
median_ratio <- c()
for (i in 1:length(TOFI)){
  a1 <- mean(log(MyDF$Predator.mass[MyDF$Type.of.feeding.interaction==TOFI[i]]))
  mean_pred <- c(mean_pred, a1)
  b1 <- median(log(MyDF$Predator.mass[MyDF$Type.of.feeding.interaction==TOFI[i]]))
  median_pred <- c(median_pred, b1)
  a2 <- mean(log(MyDF$Prey.mass[MyDF$Type.of.feeding.interaction==TOFI[i]]))
  mean_prey <- c(mean_prey, a2)
  b2 <- median(log(MyDF$Prey.mass[MyDF$Type.of.feeding.interaction==TOFI[i]]))
  median_prey <- c(median_prey, b2)
  a3 <- mean(log(MyDF$ratio[MyDF$Type.of.feeding.interaction==TOFI[i]]))
  mean_ratio <- c(mean_ratio, a3)
  b3 <- median(log(MyDF$ratio[MyDF$Type.of.feeding.interaction==TOFI[i]]))
  median_ratio <- c(median_ratio, b3)
}
df1=data.frame(mean_pred,mean_prey,mean_ratio)
df2=data.frame(median_pred,median_prey,median_ratio)
names(df1)[names(df1) == 'mean_pred'] <- 'Predator'
names(df1)[names(df1) == 'mean_prey'] <- 'Prey'
names(df1)[names(df1) == 'mean_ratio'] <- 'Ratio'
names(df2)[names(df2) == 'median_pred'] <- 'Predator'
names(df2)[names(df2) == 'median_prey'] <- 'Prey'
names(df2)[names(df2) == 'median_ratio'] <- 'Ratio'
df1$MeanOrMedian <- c("Mean","Mean","Mean","Mean","Mean")
df1$Type.of.feeding.interaction <- TOFI
df2$MeanOrMedian <- c("Median","Median","Median","Median","Median")
df2$Type.of.feeding.interaction <- TOFI
df_final <- rbind(df1,df2)
df_final = write.csv(df_final,"../results/PP_Results.csv")

**********************************************************************

Testing PP_Dists.R...

Output (only first 500 characters): 


**********************************************************************
[1] 34931    15
  Record.number In.refID IndividualID                   Predator
1             1  ATSH063            1 Rhizoprionodon terraenovae
2             2  ATSH080            2 Rhizoprionodon terraenovae
3             3  ATSH089            3 Rhizoprionodon terraenovae
4             4  ATSH143            4 Rhizoprionodon terraenovae
5             5  ATSH161            5 Rhizoprionodon terraenovae
6             6  ATSH166            6 Rhizoprionodon terraenovae
      Predator.common.name    
**********************************************************************

Encountered error or warning:
Loading required package: tidyverse
── Attaching packages ─────────────────────────────────────── tidyverse 1.3.0 ──
✔ ggplot2 3.3.2     ✔ purrr   0.3.4
✔ tibble  3.0.3     ✔ dplyr   1.0.1
✔ tidyr   1.1.1     ✔ stringr 1.4.0
✔ readr   1.3.1     ✔ forcats 0.5.0
── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──
✖ dplyr::filter() masks stats::filter()
✖ dplyr::lag()    masks stats::lag()

======================================================================
Inspecting script file try.R...

File contents are:

**********************************************************************
doit <- function(x) {
    temp_x <- sample(x, replace = TRUE)
    if(length(unique(temp_x))>30){
        print(paste("Mean of this sample was:", as.character(mean(temp_x))))
    }else{
        stop("Couldn't calculate mean: too few unique values!")
    }
}

popn <- rnorm(50)
hist(popn)
result <- lapply(1:15, function(i) try(doit(popn), FALSE))
result <- vector("list",15)
for (i in 1:15) {
    result[[i]] <- try(doit(popn), FALSE)
}
**********************************************************************

Testing try.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Mean of this sample was: -0.100154677577289"
[1] "Mean of this sample was: -0.143032035904408"
[1] "Mean of this sample was: -0.0249477223702539"
[1] "Mean of this sample was: -0.196005880628933"
[1] "Mean of this sample was: -0.0684402589041951"
[1] "Mean of this sample was: -0.220958262246582"
[1] "Mean of this sample was: -0.0563802997154175"
[1] "Mean of this sample was: -0.247827640259922"
[1] "Mean of this sample was: -0.184552050781762"
[1] "Mean of this sample was: 0.107039832175212"
**********************************************************************

Encountered error or warning:
Error in doit(popn) : Couldn't calculate mean: too few unique values!
Error in doit(popn) : Couldn't calculate mean: too few unique values!
Error in doit(popn) : Couldn't calculate mean: too few unique values!
Error in doit(popn) : Couldn't calculate mean: too few unique values!
Error in doit(popn) : Couldn't calculate mean: too few unique values!
Error in doit(popn) : Couldn't calculate mean: too few unique values!
Error in doit(popn) : Couldn't calculate mean: too few unique values!
Error in doit(popn) : Couldn't calculate mean: too few unique values!
Error in doit(popn) : Couldn't calculate mean: too few unique values!

======================================================================
Inspecting script file Vectorize2.R...

File contents are:

**********************************************************************
# Runs the stochastic Ricker equation with gaussian fluctuations

rm(list=ls())

stochrick<-function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
  #initialize
  N<-matrix(NA,numyears,length(p0))
  N[1,]<-p0
  
  for (pop in 1:length(p0)){#loop through the populations
    
    for (yr in 2:numyears){ #for each pop, loop through the years

      N[yr,pop] <- N[yr-1,pop] * exp(r * (1 - N[yr - 1,pop] / K) + rnorm(1,0,sigma))
    
    }
  
  }
 return(N)

}

# Now write another function called stochrickvect that vectorizes the above 
# to the extent possible, with improved performance: 

stochrickvect<-function(p0=runif(1000,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
  #initialize
  N<-matrix(NA,numyears,length(p0))
  N[1,]<-p0
    for (yr in 2:numyears){ #for each pop, loop through the years
      N[yr,] <- N[yr-1,] * exp(r * (1 - N[yr - 1,] / K) + rnorm(1,0,sigma))
    }
 return(N)
}

# pop
stochrick1<-function(p0=runif(100,.5,1.5),r=1.2,K=1,sigma=0.2,numyears=100)
{
  #initialize
  N<-matrix(NA,numyears,1000)
  N[1,]<-p0
  for (pop in 2:1000){#loop through the populations
    #for (yr in 2:numyears){ #for each pop, loop through the years
      N[,pop] <- N[,pop-1] * exp(r * (1 - N[,pop-1] / K) + rnorm(1,0,sigma))
    #}
  }
  return(N)
}


print("Vectorized Stochastic Ricker takes:")
print(system.time(res2<-stochrick()))
print("Vectorized Stochastic_Ricker_Vect takes:")
print(system.time(res2<-stochrickvect()))
print("Vectorized Stochastic_Ricker_Vect takes:")
print(system.time(res2<-stochrick1()))
**********************************************************************

Testing Vectorize2.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Vectorized Stochastic Ricker takes:"
   user  system elapsed 
  0.293   0.027   0.322 
[1] "Vectorized Stochastic_Ricker_Vect takes:"
   user  system elapsed 
  0.012   0.000   0.012 
[1] "Vectorized Stochastic_Ricker_Vect takes:"
   user  system elapsed 
  0.016   0.000   0.016 

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.62084s

======================================================================
Inspecting script file TAutoCorr.R...

File contents are:

**********************************************************************
KWAMT = load("../data/KeyWestAnnualMeanTemperature.RData")
year = ats$Year
temp = ats$Temp

# Compute the appropriate correlation coefficient between successive years and store it (cor())
temp1 = temp[-1]
temp2 = temp[-length(temp)]
result = cor(temp1,temp2)
print(result)

Tresult <- vector()
Greater <- vector()
i=1
j=1
while (i<=10000) {
  ts = sample(temp)
  ts1 = ts[-1]
  ts2 = ts[-length(ts)]
  Tresult[[i]] <- cor(ts1,ts2)
  #print(Tresult)
  if(Tresult[[i]]>result){
    Greater[[j]] <- Tresult[[i]]
    j = j +1
  }
  i = i+1
}
hist(Tresult, main = "Calculate 10000 times", xlab = "result" , ylab = "times")
if(length(Greater)>0){
  print(Greater)
  print(length(Greater)/10000)
}else{
  print("No greater value.")
}


**********************************************************************

Testing TAutoCorr.R...

Output (only first 500 characters): 


**********************************************************************
[1] 0.3261697
[1] 0.3487601 0.3294629 0.3394838 0.3450318 0.3833885
[1] 5e-04

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.74730s

======================================================================
Inspecting script file boilerplate.R...

File contents are:

**********************************************************************
# A boilerplate R script

MyFunction <- function(Arg1, Arg2){
  
  # Statements involving Arg1, Arg2:
  print(paste("Argument", as.character(Arg1), "is a", class(Arg1))) # print Arg1's type
  print(paste("Argument", as.character(Arg2), "is a", class(Arg2))) # print Arg2's type
    
  return (c(Arg1, Arg2)) #this is optional, but very useful
}

MyFunction(1,2) #test the function
MyFunction("Riki","Tiki") #A different test


**********************************************************************

Testing boilerplate.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Argument 1 is a numeric"
[1] "Argument 2 is a numeric"
[1] 1 2
[1] "Argument Riki is a character"
[1] "Argument Tiki is a character"
[1] "Riki" "Tiki"

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.21022s

======================================================================
Inspecting script file apply1.R...

File contents are:

**********************************************************************
## Build a random matrix
M <- matrix(rnorm(100), 10, 10)

## Take the mean of each row
RowMeans <- apply(M, 1, mean)
print (RowMeans)

## Now the variance
RowVars <- apply(M, 1, var)
print (RowVars)

## By column
ColMeans <- apply(M, 2, mean)
print (ColMeans)


**********************************************************************

Testing apply1.R...

Output (only first 500 characters): 


**********************************************************************
 [1] -0.208221894 -0.994570973  0.151071741  0.007429717 -0.164245913
 [6]  0.026637277 -0.001254554 -0.146775008 -0.281196255  0.225816909
 [1] 0.7242741 0.9895196 0.6372796 2.0556013 0.7806386 0.8053919 0.9046735
 [8] 0.9304343 0.4587300 0.4757870
 [1] -0.377279182 -0.584467305 -0.198732126 -0.165320907 -0.349590942
 [6]  0.305683133  0.242670233 -0.414086916  0.147374853  0.008440203

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.20493s

======================================================================
Inspecting script file PP_Regress.R...

File contents are:

**********************************************************************
rm(list = ls())
MyDF <- read.csv("../data/EcolArchives-E089-51-D1.csv")
MyDF$Type.of.feeding.interaction <- as.factor(MyDF$Type.of.feeding.interaction)
MyDF$Location <- as.factor(MyDF$Location)
require(ggplot2)
require(ggthemes)
pdf("../results/PP_Regress.pdf")
p <- ggplot(MyDF,aes(x=log(Prey.mass), y=log(Predator.mass), colour = Predator.lifestage))+
  labs(x="Predator mass in grams",y="Prey mass in grams")+
  geom_point(shape = 3)+
  facet_grid(Type.of.feeding.interaction ~.)+
  geom_smooth(method = "lm", fullrange = T)+
  theme(legend.position = "bottom")+
  guides(col = guide_legend(nrow=1))
p
graphics.off()

Lifestage <- unique(MyDF$Predator.lifestage)
df <- data.frame()


for (l in 1:length(Lifestage)){
  sub_L <- subset(MyDF, Predator.lifestage == Lifestage[l])
  TOFI <- unique(sub_L$Type.of.feeding.interaction)
  for (t in 1:length(TOFI)) {
    sub_T <- subset(sub_L, Type.of.feeding.interaction == TOFI[t])
    if (nrow(sub_T)>2){
      out <- summary(lm(log(Predator.mass)~log(Prey.mass), sub_T))
      df1 <- data.frame(R2 = out$r.squared,
                      f.value = as.numeric(out$fstatistic[1]),
                      p.value = out$coefficients[2,4],
                      Slope = out$coefficients[2],
                      Intercept = out$coefficients[1],
                      predator.lifestage = Lifestage[l],
                      Type.of.feeding.interaction = TOFI[t])
      df <- rbind(df,df1)
    }
  }
}

df = write.csv(df, "../results/PP_Regress_Results.csv")


**********************************************************************

Testing PP_Regress.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error or warning:
Loading required package: ggplot2
Loading required package: ggthemes
`geom_smooth()` using formula 'y ~ x'
Warning messages:
1: In qt((1 - level)/2, df) : NaNs produced
2: In max(ids, na.rm = TRUE) :
  no non-missing arguments to max; returning -Inf

======================================================================
Inspecting script file MyBars.R...

File contents are:

**********************************************************************
pdf("../results/MyBars.pdf")

p <- ggplot(MyDF, aes(x = log(Predator.mass),
                      y = log(Prey.mass),
                      colour = Type.of.feeding.interaction))
p + geom_point()
q <- p + 
  geom_point(size=I(2), shape=I(10)) +
  theme_bw() + # make the background white
  theme(aspect.ratio=1) # make the plot square
q
plot(q)

q+theme(legend.position = "none") + theme(aspect.ratio = 1)
p <- ggplot(MyDF,aes(x=log(Prey.mass/Predator.mass), fill = Type.of.feeding.interaction))+geom_density()
p
p <- ggplot(MyDF,aes(x=log(Prey.mass/Predator.mass), fill = Type.of.feeding.interaction))+geom_density(alpha=0.5)
p
plot(p)
p <- ggplot(MyDF,aes(x=log(Prey.mass/Predator.mass), fill = Type.of.feeding.interaction))+geom_density()+facet_wrap( .~Type.of.feeding.interaction)
p
plot(p)
p <- ggplot(MyDF,aes(x=log(Prey.mass/Predator.mass), fill = Type.of.feeding.interaction))+geom_density()+facet_wrap(.~Type.of.feeding.interaction, scales = "free")
p
p <- ggplot(MyDF,aes(x=log(Prey.mass/Predator.mass)))+geom_density()+facet_wrap( .~Location, scales = "free")
p
plot(p)
p <- ggplot(MyDF,aes(x=log(Prey.mass),y=log(Predator.mass)))+geom_point()+facet_wrap( .~Location, scales = "free")
p
plot(p)
p <- ggplot(MyDF,aes(x=log(Prey.mass),y=log(Predator.mass)))+geom_point()+facet_wrap( .~Location + Type.of.feeding.interaction, scales = "free")
p


require(reshape2)
GenerateMatrix <- function(N){
  M <- matrix(runif(N*N),N,N)
  return(M)
}
M <- GenerateMatrix(10)
Melt <- melt(M)
p <- ggplot(Melt, aes(Var1, Var2, fill = value)) + geom_tile() + theme(aspect.ratio = 1)
p
plot(p)
p + geom_tile(colour = "black") + theme(aspect.ratio = 1)
p + theme(legend.position = "none")
p + scale_fill_continuous(low = "yellow", high = "darkgreen")
p + scale_fill_gradient2()
p + scale_fill_gradientn(colours = grey.colors(10))
p + scale_fill_gradientn(colours = rainbow(10))
p + scale_fill_gradientn(colours = c("red", "white", "blue"))


build_ellipse <- function(hradius, vradius){ # function that returns an ellipse
  npoints = 250
  a <- seq(0, 2 * pi, length = npoints + 1)
  x <- hradius * cos(a)
  y <- vradius * sin(a)  
  return(data.frame(x = x, y = y))
}
N <- 250 # Assign size of the matrix

M <- matrix(rnorm(N * N), N, N) # Build the matrix

eigvals <- eigen(M)$values # Find the eigenvalues

eigDF <- data.frame("Real" = Re(eigvals), "Imaginary" = Im(eigvals)) # Build a dataframe

my_radius <- sqrt(N) # The radius of the circle is sqrt(N)

ellDF <- build_ellipse(my_radius, my_radius) # Dataframe to plot the ellipse

names(ellDF) <- c("Real", "Imaginary") # rename the columns
# plot the eigenvalues
p <- ggplot(eigDF, aes(x = Real, y = Imaginary))
p <- p +
  geom_point(shape = I(3)) +
  theme(legend.position = "none")

# now add the vertical and horizontal line
p <- p + geom_hline(aes(yintercept = 0))
p <- p + geom_vline(aes(xintercept = 0))

# finally, add the ellipse
p <- p + geom_polygon(data = ellDF, aes(x = Real, y = Imaginary, alpha = 1/20, fill = "red"))
p
plot(p)

a <- read.table("../data/Results.txt", header = T)
a$ymin <- rep(0,dim(a)[1])
p <- ggplot(a)
p <- p + geom_linerange(data = a, aes(x=x, ymin=ymin, ymax=y1, size=(0.5)), colour = "#E69F00", alpha=1/2, show.legend = F)
p <- p + geom_linerange(data = a, aes(x=x, ymin=ymin, ymax=y2, size=(0.5)), colour = "#56B4E9", alpha=1/2, show.legend = F)
p <- p + geom_linerange(data = a, aes(x=x, ymin=ymin, ymax=y3, size=(0.5)), colour = "#D55E00", alpha=1/2, show.legend = F)
p <- p + geom_text(data = a, aes(x=x, y=-500, label = Label))
p <- p + scale_x_continuous("My x axis", breaks = seq(3,5,by=0.05))+ scale_y_continuous("My y axis") + theme_bw() + theme(legend.position = "none")
p
plot(p)

dev.off()
**********************************************************************

Testing MyBars.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error or warning:
Error in ggplot(MyDF, aes(x = log(Predator.mass), y = log(Prey.mass),  : 
  could not find function "ggplot"
Execution halted

======================================================================
Inspecting script file DataWrang.R...

File contents are:

**********************************************************************
################################################################
################## Wrangling the Pound Hill Dataset ############
################################################################

############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../data/PoundHillData.csv", header = FALSE))

# header = true because we do have metadata headers
MyMetaData <- read.csv("../data/PoundHillMetaData.csv", header = TRUE, sep = ";")

############# Inspect the dataset ###############
head(MyData)
dim(MyData)
str(MyData)
fix(MyData) #you can also do this
fix(MyMetaData)

############# Transpose ###############
# To get those species into columns and treatments into rows 
MyData <- t(MyData) 
head(MyData)
dim(MyData)

############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0

############# Convert raw matrix to data frame ###############

TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) #stringsAsFactors = F is important!
colnames(TempData) <- MyData[1,] # assign column names from original data

############# Convert from wide to long format  ###############
require(reshape2) # load the reshape2 package

?melt #check out the melt function

MyWrangledData <- melt(TempData, id=c("Cultivation", "Block", "Plot", "Quadrat"), variable.name = "Species", value.name = "Count")

MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])

str(MyWrangledData)
head(MyWrangledData)
dim(MyWrangledData)

############# Exploring the data (extend the script below)  ###############

**********************************************************************

Testing DataWrang.R...

Output (only first 500 characters): 


**********************************************************************
     V1                     V2        V3        V4        V5        V6       
[1,] "Cultivation"          "october" "october" "october" "october" "october"
[2,] "Block"                "a"       "a"       "a"       "a"       "a"      
[3,] "Plot"                 "1"       "1"       "1"       "1"       "1"      
[4,] "Quadrat"              "Q1"      "Q2"      "Q3"      "Q4"      "Q5"     
[5,] "Achillea millefolium" "4"       "8"       "3"       "20"      "6"      
[6,] "Agrostis gigantea"    ""   
**********************************************************************

Encountered error or warning:
Loading required package: reshape2

======================================================================
Inspecting script file control_flow.R...

File contents are:

**********************************************************************
a <- TRUE
if (a == TRUE){
    print ("a is TRUE")
    } else {
    print ("a is FALSE")
}

z <- runif(1) ## Generate a uniformly distributed random number
if (z <= 0.5) {print ("Less than a half")}

for (i in 1:10){
    j <- i * i
    print(paste(i, " squared is", j ))
}

for(species in c('Heliodoxa rubinoides', 
                 'Boissonneaua jardini', 
                 'Sula nebouxii')){
  print(paste('The species is', species))
}

v1 <- c("a","bc","def")
for (i in v1){
    print(i)
}

i <- 0
while (i < 10){
    i <- i+1
    print(i^2)
}


**********************************************************************

Testing control_flow.R...

Output (only first 500 characters): 


**********************************************************************
[1] "a is TRUE"
[1] "Less than a half"
[1] "1  squared is 1"
[1] "2  squared is 4"
[1] "3  squared is 9"
[1] "4  squared is 16"
[1] "5  squared is 25"
[1] "6  squared is 36"
[1] "7  squared is 49"
[1] "8  squared is 64"
[1] "9  squared is 81"
[1] "10  squared is 100"
[1] "The species is Heliodoxa rubinoides"
[1] "The species is Boissonneaua jardini"
[1] "The species is Sula nebouxii"
[1] "a"
[1] "bc"
[1] "def"
[1] 1
[1] 4
[1] 9
[1] 16
[1] 25
[1] 36
[1] 49
[1] 64
[1] 81
[1] 100

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.23482s

======================================================================
Inspecting script file Vectorize1.R...

File contents are:

**********************************************************************
M <- matrix(runif(1000000),1000,1000)

SumAllElements <- function(M){
  Dimensions <- dim(M)
  Tot <- 0
  for (i in 1:Dimensions[1]){
    for (j in 1:Dimensions[2]){
      Tot <- Tot + M[i,j]
    }
  }
  return (Tot)
}
 
print("Using loops, the time taken is:")
print(system.time(SumAllElements(M)))

print("Using the in-built vectorized function, the time taken is:")
print(system.time(sum(M)))
**********************************************************************

Testing Vectorize1.R...

Output (only first 500 characters): 


**********************************************************************
[1] "Using loops, the time taken is:"
   user  system elapsed 
  0.093   0.000   0.093 
[1] "Using the in-built vectorized function, the time taken is:"
   user  system elapsed 
  0.002   0.000   0.001 

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.38633s

======================================================================
Inspecting script file SQLinR.R...

File contents are:

**********************************************************************
#install the sqlite package
install.packages('sqldf')

# To load the packages
library(sqldf)

# The command below opens a connection to the database.
#If the database does not yet exist, one is created in the working directory of R.
db <- dbConnect(SQLite(), dbname='Test.sqlite')

# Now let's enter some data to the table
# Using the db connection to our database, the data are entered using SQL queries
# The next command just create the table
dbSendQuery(conn = db,
            "CREATE TABLE Consumer
       (OriginalID TEXT,
        ConKingdom TEXT,
        ConPhylum TEXT,
        ConSpecies TEXT)")

# Once the table is created, we can enter the data.
#INSERT specifies where the data is entered (here the School table).
#VALUES contains the data

 dbSendQuery(conn = db,
         "INSERT INTO Consumer
         VALUES (1, 'Animalia', 'Arthropoda', 'Chaoborus trivittatus')")
 dbSendQuery(conn = db,
         "INSERT INTO Consumer
         VALUES (2, 'Animalia', 'Arthropoda', 'Chaoborus americanus')")
 dbSendQuery(conn = db,
         "INSERT INTO Consumer
         VALUES (3, 'Animalia', 'Chordata', 'Stizostedion vitreum')")


# Once we have our table, we can query the results using:

dbGetQuery(db, "SELECT * FROM Consumer")
dbGetQuery(db, "SELECT * FROM Consumer WHERE ConPhylum='Chordata'")


# Tables can be also imported from csv files.
# As example, let's use the Biotraits dataset.
# The easiest way is to read the csv files into R as data frames.
# Then the data frames are imported into the database.

Resource <- read.csv("../Data/Resource.csv")  # Read csv files into R

# Import data frames into database
 dbWriteTable(conn = db, name = "Resource", value = Resource, row.names = FALSE)

# Check that the data have been correctly imported into the School table.
 dbListTables(db)                 # The tables in the database
 dbListFields(db,"Resource")       # The columns in a table
 dbReadTable(db, "Resource")    # The data in a table

# Before leaving RSQLite, there is a bit of tidying-up to do.
# The connection to the database is closed, and as precaution
# the three data frames are removed from R’s environment.
 dbDisconnect(db)            # Close connection
 rm(list = c("Resource"))   # Remove data frames



**********************************************************************

Testing SQLinR.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error or warning:
Installing package into ‘/usr/local/lib/R/site-library’
(as ‘lib’ is unspecified)
Warning in install.packages("sqldf") :
  'lib = "/usr/local/lib/R/site-library"' is not writable
Error in install.packages("sqldf") : unable to install packages
Execution halted

======================================================================
Inspecting script file sample.R...

File contents are:

**********************************************************************
######### Functions ##########

## A function to take a sample of size n from a population "popn" and return its mean
myexperiment <- function(popn,n){
    pop_sample <- sample(popn, n, replace = FALSE)
    return(mean(pop_sample))
}

## Calculate means using a for loop without preallocation:
loopy_sample1 <- function(popn, n, num){
    result1 <- vector() #Initialize empty vector of size 1 
    for(i in 1:num){
        result1 <- c(result1, myexperiment(popn, n))
    }
    return(result1)
}

## To run "num" iterations of the experiment using a for loop on a vector with preallocation:
loopy_sample2 <- function(popn, n, num){
    result2 <- vector(,num) #Preallocate expected size
    for(i in 1:num){
        result2[i] <- myexperiment(popn, n)
    }
    return(result2)
}

## To run "num" iterations of the experiment using a for loop on a list with preallocation:
loopy_sample3 <- function(popn, n, num){
    result3 <- vector("list", num) #Preallocate expected size
    for(i in 1:num){
        result3[[i]] <- myexperiment(popn, n)
    }
    return(result3)
}


## To run "num" iterations of the experiment using vectorization with lapply:
lapply_sample <- function(popn, n, num){
    result4 <- lapply(1:num, function(i) myexperiment(popn, n))
    return(result4)
}

## To run "num" iterations of the experiment using vectorization with lapply:
sapply_sample <- function(popn, n, num){
    result5 <- sapply(1:num, function(i) myexperiment(popn, n))
    return(result5)
}

popn <- rnorm(1000) # Generate the population
hist(popn)

n <- 20 # sample size for each experiment
num <- 1000 # Number of times to rerun the experiment

print("The loopy, non-preallocation approach takes:" )
print(system.time(loopy_sample1(popn, n, num)))

print("The loopy, but with preallocation approach takes:" )
print(system.time(loopy_sample2(popn, n, num)))

print("The loopy, non-preallocation approach on a list takes:" )
print(system.time(loopy_sample3(popn, n, num)))

print("The vectorized sapply approach takes:" )
print(system.time(sapply_sample(popn, n, num)))

print("The vectorized lapply approach takes:" )
print(system.time(lapply_sample(popn, n, num)))
**********************************************************************

Testing sample.R...

Output (only first 500 characters): 


**********************************************************************
[1] "The loopy, non-preallocation approach takes:"
   user  system elapsed 
  0.030   0.012   0.042 
[1] "The loopy, but with preallocation approach takes:"
   user  system elapsed 
  0.017   0.000   0.017 
[1] "The loopy, non-preallocation approach on a list takes:"
   user  system elapsed 
  0.017   0.000   0.017 
[1] "The vectorized sapply approach takes:"
   user  system elapsed 
  0.016   0.000   0.016 
[1] "The vectorized lapply approach takes:"
   user  system elapsed 
  0.013   0.000   0.
**********************************************************************

Code ran without errors or warnings

Time consumed = 0.48738s

======================================================================
Inspecting script file apply2.R...

File contents are:

**********************************************************************
SomeOperation <- function(v){ # (What does this function do?)
  if (sum(v) > 0){ #note that sum(v) is a single (scalar) value
    return (v * 100)
  }
  return (v)
}

M <- matrix(rnorm(100), 10, 10)
print (apply(M, 1, SomeOperation))
**********************************************************************

Testing apply2.R...

Output (only first 500 characters): 


**********************************************************************
            [,1]         [,2]        [,3]       [,4]       [,5]       [,6]
 [1,]  1.2487617  -97.1748619  0.04836657  231.14195  0.8612619 -77.788941
 [2,] -0.5292969 -112.5920613 -0.65160564  -46.93004 -0.9346392  -2.264454
 [3,]  0.4827254  -13.3672429 -0.42539467  -14.02254  1.1128808  18.201254
 [4,] -1.4422749   35.4229952  1.39126967  161.87278 -1.5419238 -74.241736
 [5,] -1.9812006  107.9465469 -0.72098830   49.16884 -1.2682640 -29.164520
 [6,]  0.3930232   70.6412253 -1.13598966 -119.9886
**********************************************************************

Code ran without errors or warnings

Time consumed = 0.24401s

======================================================================
Inspecting script file Ricker.R...

File contents are:

**********************************************************************
Ricker <- function(N0=1, r=1, K=10, generations=50)
{
  # Runs a simulation of the Ricker model
  # Returns a vector of length generations
  
  N <- rep(NA, generations)    # Creates a vector of NA
  
  N[1] <- N0
  for (t in 2:generations)
  {
    N[t] <- N[t-1] * exp(r*(1.0-(N[t-1]/K)))
  }
  return (N)
}

plot(Ricker(generations=10), type="l")
**********************************************************************

Testing Ricker.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.25648s

======================================================================
Inspecting script file break.R...

File contents are:

**********************************************************************
i <- 0 #Initialize i
    while(i < Inf) {
        if (i == 10) {
            break 
        } # Break out of the while loop! 
        else { 
            cat("i equals " , i , " \n")
            i <- i + 1 # Update i
        }
    }
**********************************************************************

Testing break.R...

Output (only first 500 characters): 


**********************************************************************
i equals  0  
i equals  1  
i equals  2  
i equals  3  
i equals  4  
i equals  5  
i equals  6  
i equals  7  
i equals  8  
i equals  9  

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.20955s

======================================================================
Inspecting script file next.R...

File contents are:

**********************************************************************
for (i in 1:10) {
    if ((i %% 2) == 0) # check if the number is odd
        next # pass to next iteration of loop 
    print(i)
}
**********************************************************************

Testing next.R...

Output (only first 500 characters): 


**********************************************************************
[1] 1
[1] 3
[1] 5
[1] 7
[1] 9

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.23050s

======================================================================
Inspecting script file R_conditionals.R...

File contents are:

**********************************************************************
# Checks if an integer is even
is.even <- function(n = 2){
  if (n %% 2 == 0)
  {
    return(paste(n,'is even!'))
  } 
  return(paste(n,'is odd!'))
}

is.even(6)

# Checks if a number is a power of 2
is.power2 <- function(n = 2){
  if (log2(n) %% 1==0)
  {
    return(paste(n, 'is a power of 2!'))
  } 
  return(paste(n,'is not a power of 2!'))
}

is.power2(4)

# Checks if a number is prime
is.prime <- function(n){
  if (n==0){
    return(paste(n,'is a zero!'))
  }
  if (n==1){
    return(paste(n,'is just a unit!'))
  }
  ints <- 2:(n-1)
  if (all(n%%ints!=0)){
    return(paste(n,'is a prime!'))
  } 
  return(paste(n,'is a composite!'))
}

is.prime(3)
**********************************************************************

Testing R_conditionals.R...

Output (only first 500 characters): 


**********************************************************************
[1] "6 is even!"
[1] "4 is a power of 2!"
[1] "3 is a prime!"

**********************************************************************

Code ran without errors or warnings

Time consumed = 0.18644s

======================================================================
Inspecting script file GPDD_Data.R...

File contents are:

**********************************************************************
rm(list = ls())
load("../data/GPDDFiltered.RData")
require(maps)
require(ggplot2)
mp <- NULL
mapworld <- borders('world', colour = "gray 50", fill = "white")
mp <- ggplot() + mapworld
mp <- mp + geom_point(aes(x=gpdd$long, y=gpdd$lat), color = "darkorange", shape = I(3)) + scale_size(range = c(1,1))
mp <- mp + theme(legend.position = "bottom")
mp


# Most of them are by the sea. And most of them are in Europe and North America
**********************************************************************

Testing GPDD_Data.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error or warning:
Loading required package: maps
Loading required package: ggplot2

======================================================================
Inspecting script file basic_io.R...

File contents are:

**********************************************************************
# A simple script to illustrate R input-output.  
# Run line by line and check inputs outputs to understand what is happening  

MyData <- read.csv("../data/trees.csv", header = TRUE) # import with headers

write.csv(MyData, "../results/MyData.csv") #write it out as a new file

write.table(MyData[1,], file = "../results/MyData.csv",append=TRUE) # Append to it

write.csv(MyData, "../results/MyData.csv", row.names=TRUE) # write row names

write.table(MyData, "../results/MyData.csv", col.names=FALSE) # ignore column names
**********************************************************************

Testing basic_io.R...

Output (only first 500 characters): 


**********************************************************************

**********************************************************************

Encountered error or warning:
Warning message:
In write.table(MyData[1, ], file = "../results/MyData.csv", append = TRUE) :
  appending column names to file

======================================================================
Inspecting script file AutocorrelationInWeather.tex...

File contents are:

**********************************************************************
\documentclass[10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage{xcolor}
\lstset{
    numbers=left,numberstyle=\tiny,
    keywordstyle=\color{blue},commentstyle=\color[cmyk]{1,0,1,0},frame=single,escapeinside=``,extendedchars=false,
    xleftmargin=2em,xrightmargin=2em,aboveskip=1em,tabsize=4,showspaces=false
}

\title{AutocorrelationInWeather}
\author{Dengkui Tang}
\date{October 2020}

\begin{document}

\maketitle

\section{Compute the appropriate correlation coefficient between successive years and store it.}
    \subsection{Load the data from "KeyWestAnnualMeanTemperature.RData"}
    \begin{lstlisting}[language={R}]
    KWAMT = load("../data/KeyWestAnnualMeanTemperature.RData")
    \end{lstlisting}
    \subsection{Read and store data for each column(Year,Temp)}
    \begin{lstlisting}[language={R}]
    year=ats$Year
    temp=ats$Temp
    \end{lstlisting}
    \subsection{Calculate(cor())}
    \begin{lstlisting}[language={R}]
    result=cor(temp1,temp2)
    \end{lstlisting}

\section{Repeat this calculation 10000 times by - randomly permuting the time series, and then recalculating the correlation coefficient for each randomly permuted year sequence and storing it}
    \subsection{Disorganize "Temp" (use the sample function)}
    \begin{lstlisting}[language={R}]
    ts=sample(temp)
    \end{lstlisting}
    \subsection{Calculate(the same as 1.c)}
    \begin{lstlisting}[language={R}]
    ts1=ts[-1]
    ts2=ts[-length(ts)]
    \end{lstlisting}
    \subsection{Loop 10000 times and draw a diagram}
    \begin{lstlisting}[language={R}]
    i=1
    while(i<=10000){
        Tresult[[i]]<-cor(ts1,ts2)
    }
    hist(Tresult)
    \end{lstlisting}

\section{Calculate what fraction of the correlation coefficients from the previous step were greater than that from step1.}
    \subsection{Create a vector}
    \begin{lstlisting}[language={R}]
    Greater<-vector()
    \end{lstlisting}
    \subsection{Use an "if" to judge whether it is greater than "result", and add it into "Greater".}
    \begin{lstlisting}[language={R}]
    if(Tresult[[i]]>result){
        Greater[[j]]<-Tresult[[i]]
        j=j+1
    }
    \end{lstlisting}
    \subsection{judge whether "Greater" is empty or not}
    \begin{lstlisting}[language={R}]
    if(length(Greater)>0){
        print(length(Greater)/10000)
    }else{
        print("No greater value.")
    }
    \end{lstlisting}

\end{document}

**********************************************************************

Testing AutocorrelationInWeather.tex...

Output (only first 500 characters): 


**********************************************************************
This is pdfTeX, Version 3.14159265-2.6-1.40.20 (TeX Live 2019/Debian) (preloaded format=pdflatex)
 restricted \write18 enabled.
entering extended mode
(./AutocorrelationInWeather.tex
LaTeX2e <2020-02-02> patch level 2
L3 programming layer <2020-02-14>
(/usr/share/texlive/texmf-dist/tex/latex/base/article.cls
Document Class: article 2019/12/20 v1.4l Standard LaTeX document class
(/usr/share/texlive/texmf-dist/tex/latex/base/size10.clo))
(/usr/share/texlive/texmf-dist/tex/latex/base/inputenc.sty)
(
**********************************************************************

Code ran without errors or warnings

Time consumed = 1.14228s

======================================================================
Inspecting script file DataWrangTidy.R...

File contents are:

**********************************************************************
################################################################
################## Wrangling the Pound Hill Dataset ############
################################################################

############# Load the dataset ###############
# header = false because the raw data don't have real headers
MyData <- as.matrix(read.csv("../data/PoundHillData.csv", header = FALSE))

# header = true because we do have metadata headers
MyMetaData <- read.csv("../data/PoundHillMetaData.csv", header = TRUE, sep = ";")

############# Inspect the dataset ###############
head(MyData)
dim(MyData)
str(MyData)
fix(MyData) #you can also do this
fix(MyMetaData)

############# Transpose ###############
# To get those species into columns and treatments into rows 
MyData <- t(MyData) 
head(MyData)
dim(MyData)

############# Replace species absences with zeros ###############
MyData[MyData == ""] = 0

############# Convert raw matrix to data frame ###############

TempData <- as.data.frame(MyData[-1,],stringsAsFactors = F) #stringsAsFactors = F is important!
colnames(TempData) <- MyData[1,] # assign column names from original data

############# Convert from wide to long format  ###############
require(reshape2) # load the reshape2 package

?melt #check out the melt function

MyWrangledData <- melt(TempData, id=c("Cultivation", "Block", "Plot", "Quadrat"), variable.name = "Species", value.name = "Count")

MyWrangledData[, "Cultivation"] <- as.factor(MyWrangledData[, "Cultivation"])
MyWrangledData[, "Block"] <- as.factor(MyWrangledData[, "Block"])
MyWrangledData[, "Plot"] <- as.factor(MyWrangledData[, "Plot"])
MyWrangledData[, "Quadrat"] <- as.factor(MyWrangledData[, "Quadrat"])
MyWrangledData[, "Count"] <- as.integer(MyWrangledData[, "Count"])

str(MyWrangledData)
head(MyWrangledData)
dim(MyWrangledData)

############# Exploring the data (extend the script below)  ###############

MyGatherData <- gather(TempData, Species, Count, 5:ncol(TempData))


**********************************************************************

Testing DataWrangTidy.R...

Output (only first 500 characters): 


**********************************************************************
     V1                     V2        V3        V4        V5        V6       
[1,] "Cultivation"          "october" "october" "october" "october" "october"
[2,] "Block"                "a"       "a"       "a"       "a"       "a"      
[3,] "Plot"                 "1"       "1"       "1"       "1"       "1"      
[4,] "Quadrat"              "Q1"      "Q2"      "Q3"      "Q4"      "Q5"     
[5,] "Achillea millefolium" "4"       "8"       "3"       "20"      "6"      
[6,] "Agrostis gigantea"    ""   
**********************************************************************

Encountered error or warning:
Loading required package: reshape2
Error in gather(TempData, Species, Count, 5:ncol(TempData)) : 
  could not find function "gather"
Execution halted

======================================================================
======================================================================
Finished running scripts

Ran into 10 errors or warnings

Total time used: 19.61s 

======================================================================

FINISHED WEEKLY ASSESSMENT

Current Points for the Week = 99.5

NOTE THAT THESE ARE POINTS, NOT MARKS FOR THE WEEK!