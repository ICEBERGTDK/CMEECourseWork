for (i in 1:ncol(data)) {
### alleles in this SNPs
alleles <- sort(unique(data[,i]))
cat("\nSNP", i, "with alleles", alleles)
### as before, I can choose one allele as "reference"
### genotypes are Allele1/Allele1 Allele1/Allele2 Allele2/Allele2
genotype_counts <- c(0, 0, 0)
for (j in 1:nsamples) {
### indexes of genotypes for individual j
genotype_index <- c( (j*2)-1, (j*2) )
### count the Allele2 instances
genotype <- length(which(data[genotype_index, i]==alleles[2])) + 1
### increase the counter for the corresponding genotype
genotype_counts[genotype] <- genotype_counts[genotype] + 1
}
cat(" and genotype frequencies", genotype_counts)
}
### we can reuse the previous code and easily calculate the heterozygosity
nsamples <- 20
for (i in 1:ncol(data)) {
### alleles in this SNPs
alleles <- sort(unique(data[,i]))
cat("\nSNP", i, "with alleles", alleles)
### as before, I can choose one allele as "reference"
### genotypes are Allele1/Allele1 Allele1/Allele2 Allele2/Allele2
genotype_counts <- c(0, 0, 0)
for (j in 1:nsamples) {
### indexes of genotypes for individual j
genotype_index <- c( (j*2)-1, (j*2) )
### count the Allele2 instances
genotype <- length(which(data[genotype_index, i]==alleles[2])) + 1
### increase the counter for the corresponding genotype
genotype_counts[genotype] <- genotype_counts[genotype] + 1
}
cat(" and heterozygosity", genotype_counts[2]/nsamples, "and homozygosity", 1-genotype_counts[2]/nsamples)
}
nonHWE <- c() # to store indexes of SNPs deviating from HWE
nsamples <- 20
for (i in 1:ncol(data)) {
### alleles in this SNPs
alleles <- sort(unique(data[,i]))
cat("\nSNP", i)
### as before, I can choose one allele as "reference"
### frequency (of the second allele)
freq <- length(which(data[,i]==alleles[2])) / nrow(data)
### from the frequency, I can calculate the expected genotype counts under HWE
genotype_counts_expected <- c( (1-freq)^2, 2*freq*(1-freq), freq^2) * nsamples
### genotypes are Allele1/Allele1 Allele1/Allele2 Allele2/Allele2
genotype_counts <- c(0, 0, 0)
for (j in 1:nsamples) {
### indexes of genotypes for individual j
genotype_index <- c( (j*2)-1, (j*2) )
### count the Allele2 instances
genotype <- length(which(data[genotype_index, i]==alleles[2])) + 1
### increase the counter for the corresponding genotype
genotype_counts[genotype] <- genotype_counts[genotype] + 1
}
### test for HWE: calculate chi^2 statistic
chi <- sum( (genotype_counts_expected - genotype_counts)^2 / genotype_counts_expected )
## pvalue
pv <- 1 - pchisq(chi, df=1)
cat("with pvalue for test against HWE", pv)
## retain SNPs with pvalue<0.05
if (pv < 0.05) nonHWE <- c(nonHWE, i)
}
### assuming we ran the code for point 5, we already have the SNPs deviating
F <- c()
nsamples <- 20
for (i in nonHWE) {
### alleles in this SNPs
alleles <- sort(unique(data[,i]))
cat("\nSNP", i)
### as before, I can choose one allele as "reference"
### frequency (of the second allele)
freq <- length(which(data[,i]==alleles[2])) / nrow(data)
### from the frequency, I can calculate the expected genotype counts under HWE
genotype_counts_expected <- c( (1-freq)^2, 2*freq*(1-freq), freq^2) * nsamples
### genotypes are Allele1/Allele1 Allele1/Allele2 Allele2/Allele2
genotype_counts <- c(0, 0, 0)
for (j in 1:nsamples) {
### indexes of genotypes for individual j
genotype_index <- c( (j*2)-1, (j*2) )
### count the Allele2 instances
genotype <- length(which(data[genotype_index, i]==alleles[2])) + 1
### increase the counter for the corresponding genotype
genotype_counts[genotype] <- genotype_counts[genotype] + 1
}
### calculate inbreeding coefficient
inbreeding <- ( 2*freq*(1-freq) - (genotype_counts[2]/nsamples) ) / ( 2*freq*(1-freq) )
F <- c(F, inbreeding)
cat(" with inbreeding coefficient", inbreeding)
}
### plot
hist(F)
plot(F, type="h")
rm(list = ls())
### read data
data <- read.csv("bears.csv", stringsAsFactors=F, header=F, colClasses=rep("character", 10000))
dim(data)
### SNPs are positions where you observed more than one allele
### the easiest thing is to loop over all sites and record the ones with two alleles
snps <- c()
for (i in 1:ncol(data)) {
if (length(unique(data[,i]))==2) snps <- c(snps, i)
}
View(data)
### this works to retain the indexes of SNPs; a smartest way would not involve doing a loop but using `apply` functions
cat("\nNumber of SNPs is", length(snps))
### reduce the data set
data <- data[,snps]
dim(data)
rm(list = ls())
require("minpack.lm")
#Allometric scaling of traits
powMod <- function(x,a,b){
return(a * x^b)
}
MyData <- read.csv("../data/GenomeSize.csv")
Data2Fit <-  subset(MyData, Suborder == "Anisoptera")
Data2Fit <- Data2Fit[!is.na(Data2Fit$TotalLength),] # remove NA's
library("ggplot2")
#Conditional Likelihood
par(mfrow=c(1,2),bty="n")
plot(b0s, mynll[,ww[2]],type = "l", xlab = "b0", ylab = "NLL")
#Likelihood surface
N0 <- 100
N1 <- 101
b0s <- seq(7,12, length=N0)
b1s <- seq(1,5, length=N1)
mynll <- matrix(NA, nrow=N0, ncol=N1)
ww <- which(mynll==min(mynll),arr.ind = T)
b0.est <- b0s[ww[1]]
b1.est <- b1s[ww[2]]
plot(b0s, mynll[,ww[2]],type = "l", xlab = "b0", ylab = "NLL")
ww <- which(mynll==min(mynll),arr.ind = T)
b0.est <- b0s[ww[1]]
b1.est <- b1s[ww[2]]
rbind(c(b0,b1),c(b0.est,b1.est))
#Likelihood surface
N0 <- 100
N1 <- 101
b0s <- seq(7,12, length=N0)
b1s <- seq(1,5, length=N1)
mynll <- matrix(NA, nrow=N0, ncol=N1)
for (i in 1:N0) {
for (j in 1:N1) {
mynll[i,j] <- nll.slr(par = c(b0s[i],b1s[j]),dat = dat, sigma=sigma)
}
}
set.seed(123)
n <- 30
b0 <- 10
b1 <- 3
sigma <- 2
X <- rnorm(n, mean = 3, sd = 7)
Y <- b0 + b1*X + rnorm(n,mean=0, sd=sigma)
dat <- data.frame(X=X,Y=Y)
plot(X,Y)
#Likelihood profile
N <- 50
b0s <- seq(5,15,length=N)
mynll <- rep(NA, length=50)
for (i in 1:N) {
mynll[i] <- nll.slr(par=c(b0s[i], b1),dat = dat, sigma=sigma)
}
#Model fitting using Maximum Likelihood
#Implementing the Likelihood in R
nll.slr <- function(par, dat, ...){
args <- list(...)
b0 <- par[1]
b1 <- par[2]
X <- dat$X
Y <- dat$Y
if(!is.na(args$sigma)){
sigma <- args$sigma
}else
sigma <- par[3]
mu <- b0 + b1*X
return(-sum(dnorm(Y,mean = mu,sd=sigma,log = T)))
}
set.seed(123)
n <- 30
b0 <- 10
b1 <- 3
sigma <- 2
X <- rnorm(n, mean = 3, sd = 7)
Y <- b0 + b1*X + rnorm(n,mean=0, sd=sigma)
dat <- data.frame(X=X,Y=Y)
plot(X,Y)
#Likelihood profile
N <- 50
plot(X,Y)
#Likelihood profile
N <- 50
b0s <- seq(5,15,length=N)
mynll <- rep(NA, length=50)
for (i in 1:N) {
mynll[i] <- nll.slr(par=c(b0s[i], b1),dat = dat, sigma=sigma)
}
plot(b0s, mynll, type="l")
abline(v=b0,col=2)
abline(v=b0s[which.min(mynll)],col=3)
#Likelihood surface
N0 <- 100
N1 <- 101
b0s <- seq(7,12, length=N0)
b1s <- seq(1,5, length=N1)
mynll <- matrix(NA, nrow=N0, ncol=N1)
for (i in 1:N0) {
for (j in 1:N1) {
mynll[i,j] <- nll.slr(par = c(b0s[i],b1s[j]),dat = dat, sigma=sigma)
}
}
ww <- which(mynll==min(mynll),arr.ind = T)
b0.est <- b0s[ww[1]]
b1.est <- b1s[ww[2]]
rbind(c(b0,b1),c(b0.est,b1.est))
filled.contour(x=b0s, y=b1s, z=mynll, col=heat.colors(21),
plot.axes = {axis(1);axis(2);points(b0,b1,pch=21);
points(b0.est, b1.est, pch=8, cex=1.5);xlab="b0";ylab="b1"})
#Conditional Likelihood
par(mfrow=c(1,2),bty="n")
plot(b0s, mynll[,ww[2]],type = "l", xlab = "b0", ylab = "NLL")
plot(b1s, mynll[ww[1]], type = "l", xlab = "b1", ylab = "NLL")
plot(b1s, mynll[ww[1],], type = "l", xlab = "b1", ylab = "NLL")
#Maximum Likelihood using optim()
fit <- optim(nll.slr, par = c(2,1), method = "L-BFGS-B",
lower = -Inf, upper = Inf, dat=dat, sigma=sigma)
fit
fit <- optim(nll.slr, par = c(2,1,5), method = "L-BFGS-B",
lower = c(-Inf, -Inf, 0.1), upper = Inf, dat=dat, sigma=NA)
fit$par
plot(X,Y)
plot(X,Y)
abline(a=fit$par[1], b=fit$par[2], col=2, lwd=2)
#Confidence intervals
fit <- optim(nll.slr, par = c(2,1), method="L-BFGS-B", hessian=TRUE, lower = -Inf, upper = Inf, dat=dat, sigma=sigma)
fisher_info <- solve(fit$hessian)
est_sigma <- sqrt(diag(fisher_info))
upper <- fit$par+1.96*est_sigma
lower <- fit$par-1.96*est_sigma
interval <- data.frame(value=fit$par, upper=upper, lower=lower)
interval
#Comparsion to fitting with least squares
lmfit <- lm(Y~X)
summary(lmfit)$coeff
#Fitting Models the Bayesian way
set.seed(54321)
pp <- c(0.1, 0.5, 0.8)
N <- 20
reps <- 50
x <- seq(0, 50, by=1)
par(mfrow=c(1,3), bty="n")
setwd("~/Documents/CMEECourseWork/MiniProject/code/")
rm(list = ls())
setwd("~/Documents/CMEECourseWork/MiniProject/code/")
require(ggplot2)
require(minpack.lm)
data <- read.csv("../data/LogisticGrowthData.csv")
View(data)
data2 <- read.csv("../data/LogisticGrowthMetaData.csv")
data1 <- read.csv("../data/LogisticGrowthData.csv")
rm(list = ls())
setwd("~/Documents/CMEECourseWork/MiniProject/code/")
require(ggplot2)
require(minpack.lm)
data1 <- read.csv("../data/LogisticGrowthData.csv")
data2 <- read.csv("../data/LogisticGrowthMetaData.csv")
View(data1)
ggplot(data1, aes(Time, PopBio))+
geom_point(size=3)+
labs(x="Time", y="PopBio")
ggplot(type = logistic, data1, aes(Time, PopBio))+
geom_point(size=3)+
labs(x="Time", y="PopBio")
ggplot(data1, aes(log(Time), log(PopBio)))+
geom_point(size=3)+
labs(x="Time", y="PopBio")
Type <- unique(data1$Species)
ggplot(data1[type[1]], aes(log(Time), log(PopBio)))+
geom_point(size=3)+
labs(x="Time", y="PopBio")
ggplot(data1[data1$Species == unique(data1$Species)[1]], aes(log(Time), log(PopBio)))+
geom_point(size=3)+
labs(x="Time", y="PopBio")
plot(data1$PopBio[data1$Species == unique(data1$Species)[1]], data1$Time[data1$Species == unique(data1$Species)[1]])
plot(data1$PopBio[data1$Species == unique(data1$Species)[1]], data1$Time[data1$Species == unique(data1$Species)[1]])
plot(data1$Time[data1$Species == unique(data1$Species)[1]], data1$PopBio[data1$Species == unique(data1$Species)[1]])
plot(data1$Time[data1$Species == unique(data1$Species)[1]], log(data1$PopBio[data1$Species == unique(data1$Species)[1]])
plot(data1$Time[data1$Species == unique(data1$Species)[1]], log(data1$PopBio[data1$Species == unique(data1$Species)[1]])
plot(data1$Time[data1$Species == unique(data1$Species)[1]], log(data1$PopBio[data1$Species == unique(data1$Species)[1]])
plot(data1$Time[data1$Species == unique(data1$Species)[1]], log(data1$PopBio[data1$Species == unique(data1$Species)[1]]))
plot(data1$Time[data1$Species == unique(data1$Species)[1]], log(data1$PopBio[data1$Species == unique(data1$Species)[1]]))
plot(data1$Time[data1$Species == Type[1]], log(data1$PopBio[data1$Species == Type[1]]))
plot(data1$Time[data1$Species == Type[1]], log(data1$PopBio[data1$Species == Type[1]]), xlab = "Time", ylab = "log(PopBio)")
#Using OLS
lm_growth <- lm(log(PopBio)~Time, data1)
current_df <- data1[data1$Species==Type[1]]
current_df <- data1[which(data1$Species==Type[1])]
current_df <- data1[which(data1$Species==Type[1])]
current_df <- data1[which(data1$Species==Type[1]),]
View(current_df)
plot(current_df$Time, log(current_df$PopBio), xlab = "Time", ylab = "log(PopBio)")
#Using OLS
lm_growth <- lm(log(PopBio)~Time, current_df)
View(lm_growth)
summary(lm_growth)
abline(lm_growth)
#Using OLS
lm_growth <- lm(log(PopBio)~poly(Time,0.5), current_df)
r = summary(lm_growth)$coefficients[2]
Intercept = summary(lm_growth)$coefficients[1]
R2 = summary(lm_growth)$r.square
current_df <- data1[which(data1$Species==Type[2]),]
plot(current_df$Time, log(current_df$PopBio), xlab = "Time", ylab = "log(PopBio)")
#Using OLS
lm_growth <- lm(log(PopBio)~poly(Time,0.5), current_df)
abline(lm_growth)
current_df <- data1[which(data1$Species==Type[1]),]
plot(current_df$Time, log(current_df$PopBio), xlab = "Time", ylab = "log(PopBio)")
#Using OLS
lm_growth <- lm(log(PopBio)~poly(Time,0.5), current_df)
abline(lm_growth)
r = summary(lm_growth)$coefficients[2] #slope(growth rate)
Intercept = summary(lm_growth)$coefficients[1] #Intercept
R2 = summary(lm_growth)$r.square
return(N_0*N_max*exp(r_max*t)/(N_max+N_0*(exp(r_max*t)-1)))
#Using NLLS
logistic_model <- function(t,r_max,N_max,N_0){
return(N_0*N_max*exp(r_max*t)/(N_max+N_0*(exp(r_max*t)-1)))
}
#first we need some starting parameters for the model
N_0_start <- min(data1$PopBio)
N_max_start <- max(data1$PopBio)
r_max_start <- 0.62
fit_logistic <- nlsLM(PopBio~logistic_model(t=Time,r_max, N_max, N_0), data1,
list(r_max=r_max_start, N_0=N_0_start, N_max=N_max_start))
#first we need some starting parameters for the model
N_0_start <- min(current_df$PopBio)
N_max_start <- max(current_df$PopBio)
r_max_start <- 0.62
fit_logistic <- nlsLM(PopBio~logistic_model(t=Time,r_max, N_max, N_0), current_df,
list(r_max=r_max_start, N_0=N_0_start, N_max=N_max_start))
summary(fit_logistic)
abline(fit_logistic)
timepoint <- seq(0,22,0.1)
timepoints <- seq(0,22,0.1)
logistic_point <- logistic_model(t=timepoints,)
logistic_point <- logistic_model(t=timepoints,
r_max=coef(fit_logistic)["r_max"],
N_max=coef(fit_logistic)["N_max"],
N_0 = coef(fit_logistic)["N_0"])
logistic_points <- logistic_model(t=timepoints,
r_max=coef(fit_logistic)["r_max"],
N_max=coef(fit_logistic)["N_max"],
N_0 = coef(fit_logistic)["N_0"])
timepoints <- seq(0,22,0.1)
df1 <- data.frame(timepoints, logistic_points)
rm timepoint
rm(timepoint)
rm(logistic_point)
df1$model <- "logistic equation"
names(df1) <- c("Time", "N", "model")
ggplot(current_df, aes(x=Time,y=PopBio))+
geom_point(size=3)+
geom_line(data=df1,aes(x=Time,y=N,col=model),size=1)+
theme(aspect.ratio = 1)+
labs(x="Time",y="log(PopBio)")
ggplot(current_df, aes(x=Time,y=PopBio))+
geom_point(size=3)+
geom_line(data=df1,aes(x=Time,y=N,col=model),size=1,fullrange = T)+
theme(aspect.ratio = 1)+
labs(x="Time",y="log(PopBio)")
#Using NLLS
logistic_model <- function(t,r_max,N_max,N_0){# The classic logistic equation
return(N_0*N_max*exp(r_max*t)/(N_max+N_0*(exp(r_max*t)-1)))
}
#first we need some starting parameters for the model
N_0_start <- min(current_df$PopBio)
N_max_start <- max(current_df$PopBio)
r_max_start <- 0.62
fit_logistic <- nlsLM(PopBio~logistic_model(t=Time,r_max, N_max, N_0), current_df,
list(r_max=r_max_start, N_0=N_0_start, N_max=N_max_start))
summary(fit_logistic)
timepoints <- seq(0,22,0.1)
logistic_points <- logistic_model(t=timepoints,
r_max=coef(fit_logistic)["r_max"],
N_max=coef(fit_logistic)["N_max"],
N_0 = coef(fit_logistic)["N_0"])
df1 <- data.frame(timepoints, logistic_points)
df1$model <- "logistic equation"
names(df1) <- c("Time", "N", "model")
ggplot(current_df, aes(x=Time,y=PopBio))+
geom_point(size=3)+
geom_line(data=df1,aes(x=Time,y=N,col=model),size=1)+
theme(aspect.ratio = 1)+
labs(x="Time",y="log(PopBio)")
#first we need some starting parameters for the model
N_0_start <- min(current_df$PopBio)
N_max_start <- max(current_df$PopBio)
r_max_start <- 0.62
fit_logistic <- nlsLM(PopBio~logistic_model(t=Time,r_max, N_max, N_0), current_df,
list(r_max=r_max_start, N_0=N_0_start, N_max=N_max_start))
summary(fit_logistic)
timepoints <- seq(0,800,1)
logistic_points <- logistic_model(t=timepoints,
r_max=coef(fit_logistic)["r_max"],
N_max=coef(fit_logistic)["N_max"],
N_0 = coef(fit_logistic)["N_0"])
df1 <- data.frame(timepoints, logistic_points)
df1$model <- "logistic equation"
names(df1) <- c("Time", "N", "model")
ggplot(current_df, aes(x=Time,y=PopBio))+
geom_point(size=3)+
geom_line(data=df1,aes(x=Time,y=N,col=model),size=1)+
theme(aspect.ratio = 1)+
labs(x="Time",y="log(PopBio)")
rm(list = ls())
cat("Reading CSV\n")
nagy <- read.csv('../data/NagyEtAl1999.csv', stringsAsFactors = FALSE)
setwd("~/Documents/CMEECourseWork/week7/code/__pycache__/")
nagy <- read.csv('../data/NagyEtAl1999.csv', stringsAsFactors = FALSE)
setwd("~/Documents/CMEECourseWork/week7/code/")
nagy <- read.csv('../data/NagyEtAl1999.csv', stringsAsFactors = FALSE)
cat("Creating graph\n")
pdf('../results/fmr_plot.pdf', 11, 8.5)
col <- c(Aves='purple3', Mammalia='red3', Reptilia='green3')
plot(log10(nagy$M.g), log10(nagy$FMR.kJ.day.1), pch=19, col=col[nagy$Class],
xlab=~log[10](M), ylab=~log[10](FMR))
for(class in unique(nagy$Class)){
model <- lm(log10(FMR.kJ.day.1) ~ log10(M.g), data=nagy[nagy$Class==class,])
abline(model, col=col[class])
}
dev.off()
cat("Finished in R!\n")
cat("Reading CSV\n")
nagy <- read.csv('../data/NagyEtAl1999.csv', stringsAsFactors = FALSE)
cat("Creating graph\n")
pdf('../results/fmr_plot.pdf', 11, 8.5)
col <- c(Aves='purple3', Mammalia='red3', Reptilia='green3')
plot(log10(nagy$M.g), log10(nagy$FMR.kJ.day.1), pch=19, col=col[nagy$Class],
xlab=~log[10](M), ylab=~log[10](FMR))
rm(list = ls())
cat("Reading CSV\n")
nagy <- read.csv('../data/NagyEtAl1999.csv', stringsAsFactors = FALSE)
View(nagy)
cat("Creating graph\n")
pdf('../results/fmr_plot.pdf', 11, 8.5)
col <- c(Aves='purple3', Mammalia='red3', Reptilia='green3')
plot(log10(nagy$M.g), log10(nagy$FMR.kJ.day.1), pch=19, col=col[nagy$Class],
xlab=~log[10](M), ylab=~log[10](FMR))
View(nagy)
rm(list = ls())
cat("Reading CSV\n")
nagy <- read.csv('../data/NagyEtAl1999.csv', stringsAsFactors = FALSE)
cat("Creating graph\n")
pdf('../results/fmr_plot.pdf', 11, 8.5)
col <- c(Aves='purple3', Mammalia='red3', Reptilia='green3')
plot(log10(nagy$M.g), log10(nagy$FMR.kJ.day.1), pch=19, col=col[nagy$Class],
xlab=~log[10](M), ylab=~log[10](FMR))
for(class in unique(nagy$Class)){
model <- lm(log10(FMR.kJ.day.1) ~ log10(M.g), data=nagy[nagy$Class==class,])
abline(model, col=col[class])
}
dev.off()
cat("Finished in R!\n")
rm(list = ls())
setwd("~/Documents/CMEECourseWork/MiniProject/code/")
require(ggplot2)
require(minpack.lm)
data1 <- read.csv("../data/LogisticGrowthData.csv")
data2 <- read.csv("../data/LogisticGrowthMetaData.csv")
Type <- unique(data1$Species)
current_df <- data1[which(data1$Species==Type[1]),]
plot(current_df$Time, log(current_df$PopBio), xlab = "Time", ylab = "log(PopBio)")
#Using OLS
lm_growth <- lm(log(PopBio)~poly(Time,0.5), current_df)
#Using OLS
lm_growth <- lm(log(PopBio)~poly(Time,0.5), current_df)
plot(current_df$Time, log(current_df$PopBio), xlab = "Time", ylab = "log(PopBio)")
#Using OLS
lm_growth <- lm(log(PopBio)~poly(Time,0.5), current_df)
#Using OLS
lm_growth <- lm(log(PopBio)~poly(Time,1), current_df)
abline(lm_growth)
r = summary(lm_growth)$coefficients[2] #slope(growth rate)
Intercept = summary(lm_growth)$coefficients[1] #Intercept
R2 = summary(lm_growth)$r.square
#Using NLLS
logistic_model <- function(t,r_max,N_max,N_0){# The classic logistic equation
return(N_0*N_max*exp(r_max*t)/(N_max+N_0*(exp(r_max*t)-1)))
}
#first we need some starting parameters for the model
N_0_start <- min(current_df$PopBio)
N_max_start <- max(current_df$PopBio)
r_max_start <- 0.62
fit_logistic <- nlsLM(PopBio~logistic_model(t=Time,r_max, N_max, N_0), current_df,
list(r_max=r_max_start, N_0=N_0_start, N_max=N_max_start))
summary(fit_logistic)
timepoints <- seq(0,800,1)
logistic_points <- logistic_model(t=timepoints,
r_max=coef(fit_logistic)["r_max"],
N_max=coef(fit_logistic)["N_max"],
N_0 = coef(fit_logistic)["N_0"])
df1 <- data.frame(timepoints, logistic_points)
df1$model <- "logistic equation"
names(df1) <- c("Time", "N", "model")
ggplot(current_df, aes(x=Time,y=PopBio))+
geom_point(size=3)+
geom_line(data=df1,aes(x=Time,y=N,col=model),size=1)+
theme(aspect.ratio = 1)+
labs(x="Time",y="log(PopBio)")
